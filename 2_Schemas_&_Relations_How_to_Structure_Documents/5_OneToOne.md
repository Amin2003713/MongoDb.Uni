## روابط یک به یک (One-to-One) در MongoDB

MongoDB اسناد (Documents) را به عنوان واحد اصلی ذخیره سازی در نظر می گیرد. برای مدل سازی روابط یک به یک، دو رویکرد اصلی
وجود دارد:

1. **اسناد تو در تو (Embedded Documents):** مناسب برای سناریوهایی که یک سند به داده های وابسته به صورت نزدیک نیاز دارد.
2. **کلکسیون های مرجع (Reference Collections):** (اختیاری) برای سناریوهای خاص که در آنها سند اصلی نباید مستقیما به سند
   دیگر وابسته باشد. (در این بخش روی اسناد تو در تو تمرکز می کنیم.)

### تنظیم روابط یک به یک با اسناد تو در تو

**1. طراحی ساختار سند:**

اولین قدم، طراحی ساختار اسناد شما برای برقراری رابطه یک به یک است. سند اصلی حاوی فیلدهای داده های اصلی و یک سند تو در تو
برای نگهداری اطلاعات وابسته خواهد بود.

**مثال:** ذخیره اطلاعات کاربر با آدرس

فرض کنید می خواهیم اطلاعات کاربر را به همراه آدرس در یک سند واحد ذخیره کنیم. ساختار سند به صورت زیر خواهد بود:

```json
{
  "_id": ObjectId("63cab8c7e4b021d2a7f78b12"),
  "name": "علی رضوی",
  "email": "ali.rezaei@example.com",
  "address": {
    "city": "تهران",
    "street": "خیابان آزادی",
    "postalCode": 12345
  }
}
```

**2. درج اسناد:**

برای درج یک سند با رابطه یک به یک، کافیست سند را با تمام فیلدها، از جمله سند تو در تو، در کلکسیون مربوطه درج کنید.

```javascript
// فرض کنید userCollection کلکسیون کاربران است
userCollection.insertOne({
  "name": "مرجان حسینی",
  "email": "marjan.hosseini@example.com",
  "address": {
    "city": "شیراز",
    "street": "خیابان حافظ",
    "postalCode": 51545
  }
})
```

### پرس و جو برای اسناد مرتبط

هنگامی که از اسناد تو در تو برای روابط یک به یک استفاده می کنید، می توانید کل سند را با یک پرس و جو بازیابی کنید.

```javascript
// بازیابی اطلاعات یک کاربر با شناسه خاص
userCollection.find({ "_id": ObjectId("63cab8c7e4b021d2a7f78b12") })
```

این پرس و جو، سند کامل کاربر با شناسه `ObjectId("63cab8c7e4b021d2a7f78b12")` را بازیابی می کند که شامل اطلاعات آدرس تو
در تو نیز می شود.

برای دسترسی به فیلدهای خاص درون سند تو در تو، می توانید از dot notation استفاده کنید.

```javascript
// بازیابی شهر محل سکونت کاربر با شناسه خاص
userCollection.find({ "_id": ObjectId("63cab8c7e4b021d2a7f78b12") }, { "address.city": 1 })
```

این پرس و جو فقط فیلد `city` را از سند تو در تو `address` بازیابی می کند.

### استفاده از متغیرها

در پرس و جوهای MongoDB می توانید از متغیرها برای بهبود خوانایی و قابلیت استفاده مجدد استفاده کنید.

```javascript
var userId = ObjectId("63cab8c7e4b021d2a7f78b12");

userCollection.find({ "_id": userId })
```

با معرفی متغیر `userId` کد خواناتر شده و در صورت نیاز به تغییر شناسه کاربر، تنها مقدار متغیر را تغییر می دهید.

## نتیجه گیری

مدل سازی روابط یک به یک با اسناد تو در تو روشی ساده و کارآمد برای سناریوهایی است که داده های وابسته به طور مرتب با هم
بازیابی می شوند. این روش پرس و جوهای ساده و کارایی قابل قبولی را ارائه می دهد. اما به یاد داشته باشید که با افزایش
پیچیدگی داده های تو در تو، اندازه سند نیز افزایش می یابد. در چنین سناریوهایی، ممکن است استفاده از کلکسیون های مرجع (که
در بخش دیگری قابل بررسی است) رویکرد مناسب تری باشد.


__________________________________________________________________________________________________________________

## روابط یک به یک با کالکشن‌های ارجاعی در MongoDB

هنگامی که اسناد تو در تو به عنوان رویکردی متداول برای روابط یک به یک در MongoDB مطرح می‌شوند، کالکشن‌های ارجاعی یک
راهکار جایگزین برای سناریوهایی هستند که:

- اسناد اصلی ممکن است به اسناد موجود در چندین کالکشن ارجاع دهند.
- ساختار اسناد تو در تو به طور مستقل تکامل یابد.
- نیاز به کنترل دقیق‌تری بر روی نرمال‌سازی داده‌ها وجود داشته باشد.

در این رویکرد، دو کالکشن اصلی برای موجودیت‌های اصلی و یک کالکشن ارجاعی برای ارتباط بین آنها ایجاد می‌شود.

### راه‌اندازی روابط یک به یک با ارجاع‌ها

1. **طراحی کالکشن‌ها:**

   سه کالکشن تعریف شود:
   - یک کالکشن برای موجودیت اصلی (به عنوان مثال، `کاربران`).
   - یک کالکشن برای موجودیت مرتبط (به عنوان مثال، `آدرس‌ها`).
   - یک کالکشن ارجاعی برای ذخیره اطلاعات ارتباطی (به عنوان مثال، `کاربران_آدرس‌ها`).

2. **ساختار کالکشن ارجاعی:**

   کالکشن ارجاعی معمولاً اسنادی را ذخیره می‌کند که شامل دو فیلد اصلی است:
   - یک کلید خارجی که به شناسه اسناد موجودیت اصلی ارجاع دارد (به عنوان مثال، `شناسه‌کاربر`).
   - یک کلید خارجی که به شناسه اسناد مرتبط ارجاع دارد (به عنوان مثال، `شناسه‌آدرس`).

**مثال:**

```json
{
  "_id": ObjectId("63cad8c7e4b021d2a7f78b16"),  // شناسه سند ارجاعی
  "userId": ObjectId("63cab8c7e4b021d2a7f78b12"),  // شناسه کاربر
  "addressId": ObjectId("63cab8c7e4b021d2a7f78b17")  // شناسه آدرس
}
```

3. **درج اسناد:**

   ابتدا اسناد را در کالکشن‌های اصلی (مانند `کاربران` و `آدرس‌ها`) درج کنید. سپس یک سند در کالکشن ارجاعی ایجاد کنید تا
   آنها را به هم متصل کنید.

**مثال (با فرض وجود اسناد در کالکشن‌های `کاربران` و `آدرس‌ها`):**

```javascript
// درج سند ارجاعی
// Insert reference document
referenceCollection.insertOne({
   "userId": userId,
   "addressId": addressId
})

```

### پرس‌وجوی اسناد با ارجاع‌ها

1. **پر کردن داده‌ها:**

   به طور پیش‌فرض، پرس‌وجوها بر روی کالکشن اصلی داده‌های مربوط به موجودیت مرتبط را به طور خودکار شامل نمی‌شوند.
   می‌توانید از مرحله لوک‌آپ (Lookup) در لوله‌ی خط لوک (Aggregation Pipeline) با استفاده از `$lookup` برای پر کردن اسناد
   مرتبط در نتایج استفاده کنید.

### پرس‌وجوی اسناد با ارجاع‌ها

1. **پر کردن داده‌ها:**

   به طور پیش‌فرض، پرس‌وجوها بر روی کالکشن اصلی داده‌های مربوط به موجودیت مرتبط را به طور خودکار شامل نمی‌شوند.
   می‌توانید از مرحله لوک‌آپ (Lookup) در لوله‌ی خط لوک (Aggregation Pipeline) با استفاده از `$lookup` برای پر کردن اسناد
   مرتبط در نتایج استفاده کنید.

2. **مثال لوک‌آپ:**

```javascript
userCollection.aggregate([
   {
      $lookup: {
         from: "addresses", // Related collection name
         localField: "_id",  // Field in main collection referencing related entity
         foreignField: "_id",  // Field in related collection being referenced
         as: "address"       // Alias for the populated related document field
      }
   }
])

```

این پرس‌وجو اسناد کاربر را با `آدرس` مرتبط و اطلاعات مرتبط آدرس را از کالکشن `آدرس‌ها` پر می‌کند.

**استفاده از متغیرها:**

مانند اسناد تو در تو، می‌توانید از متغیرها استفاده کرده و خوانایی و قابل استفاده‌بودن پرس‌وجوها را افزایش دهید.

```javascript
var userId = ObjectId("63cab8c7e4b021d2a7f78b12");

userCollection.aggregate([
  {
    $lookup: {
      from: "addresses",
      localField: "_id",
      foreignField: "_id",
      as: "address"
    }
  },
  { $match: { "_id": userId } }  // Filter by specific user ID
])
```

این مثال شناسه `شناسه‌کاربر` را معرفی می‌کند و نتایج را برای دریافت فقط کاربر با شناسه مطابقت دارنده فیلتر می‌کند.

### ملاحظات اضافی

- **کارایی:** در مقایسه با اسناد تو در تو، کالکشن‌های ارجاعی ممکن است شامل پیوستن‌های اضافی (لوک‌آپ) باشند و ممکن است
  برای بازیابی مکرر داده‌های ترکیبی بر روی کارایی تأثیر بگذارند.
- **یکپارچگی داده:** حفظ ارجاع‌ها به صورت دستی نیازمند رعایت دقیق بروزرسانی‌ها و حذف‌ها برای اطمینان از یکپارچگی داده در
  کلیه کالکشن‌ها است. در صورت لزوم، استفاده از تریگرهای پایگاه داده یا تراکنش‌ها را در نظر بگیرید.

### نتیجه‌گیری

روابط یک به یک با کالکشن‌های ارجاعی انعطاف‌پذیری و مزایای نرمال‌سازی داده را ارائه می‌دهند. با این حال، با مقایسه با
اسناد تو در تو، مقداری پیچیدگی را به همراه می‌آورند. الگوهای دسترسی به داده و نیاز به نرمال‌سازی داده خود را بررسی کرده
و رویکرد مناسب برای برنامه شما را تعیین کنید.